# 报文结构与协议

---

在 `Q2P` 系统中，数据传输是通过自定义的数据包结构来实现的。每个数据包包含了必要的头部信息和数据部分，确保在节点之间能够正确传递和解析数据。本文将详细介绍 `Q2P` 协议的数据包结构，分析每个字段的含义、长度范围及其作用。

## 1. 数据包结构

`Q2P` 的数据包由两部分组成：**头部**（固定部分）和 **数据部分**（可变长度）。数据包的头部包含了协议版本、事件类型、网络标识符（`NetworkID`）等信息，而数据部分则包含了传输的实际数据。

### 数据包头部结构

| 字段         | 描述                       | 长度（字节） | 说明                                      |
| ------------ | -------------------------- | ------------ | ----------------------------------------- |
| `NetworkID`  | 网络标识符（区分不同的 P2P 网络） | 2            | 每个网络中的节点拥有唯一的 `NetworkID`，用于标识网络 |
| `Event`      | 事件类型（如 `JOIN`、`CONNECT` 等）   | 2            | 标识当前数据包所对应的事件类型            |
| `Data Length`| 数据部分的长度               | 4            | 标明数据部分的实际大小                  |
| `Checksum`   | 校验和（可选）                | 2            | 校验数据的完整性（可选字段，取决于实现）  |

### 数据包体部分

| 字段        | 描述                      | 长度（字节） | 说明                                      |
| ----------- | ------------------------- | ------------ | ----------------------------------------- |
| `Data`      | 数据部分（如文件内容、消息等） | 可变长度     | 数据部分，根据 `Data Length` 进行分配   |

### 数据包示例

以一个 `TRANSPORT` 事件的请求为例：

| NetworkID (0x1234) | Event (TRANSPORT) | Data Length (0x0010) | Checksum (0x01F2) | Data (file chunk) |
| ------------------ | ----------------- | -------------------- | ------------------ | ------------------ |
| 0x1234             | 0x03              | 0x0010                | 0x01F2             | file chunk data    |


### 数据包构建过程

在 `Q2P` 中，每个数据包的构建过程都遵循上述结构。以下是一个数据包构建的示例：

```go
header := make([]byte, 0, 10)
binary.LittleEndian.PutUint16(header, peer.NetworkID)
binary.LittleEndian.PutUint16(header, TRANSPORT)
binary.LittleEndian.PutUint32(header, uint32(len(data)))
checksum := calculateChecksum(data)
binary.LittleEndian.PutUint16(header, checksum)
```

1. **头部构建**：首先构建数据包的头部，包括 `NetworkID`、事件类型和数据长度。
2. **校验和计算**：通过 `calculateChecksum()` 函数计算数据的校验和，确保数据完整性。
3. **数据合并**：最后，将实际的数据部分添加到数据包中，形成完整的传输数据包。

---

## 2. 事件类型与数据包

在 `Q2P` 协议中，不同的事件类型会对应不同的操作和数据格式。以下是一些常见事件类型的说明及其对应的数据包结构。

### `JOIN` 事件

`JOIN` 事件用于节点请求加入网络。当节点请求加入时，它会发送一个包含 `JOIN` 事件的数据包。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（JOIN）        | 2            |
| `Data Length`| 数据部分的长度         | 4            |
| `Data`       | 数据部分（加入请求信息）| 可变长度     |

### `CONNECT` 事件

`CONNECT` 事件用于节点之间的连接确认。当一个节点收到连接请求后，响应节点会返回 `CONNECT` 消息确认连接。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（CONNECT）     | 2            |
| `Data Length`| 数据部分的长度         | 4            |
| `Data`       | 数据部分（连接确认信息）| 可变长度     |

### `TRANSPORT` 事件

`TRANSPORT` 事件用于数据传输。当节点需要发送数据时，数据会被分片并通过 `TRANSPORT` 消息传递。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（TRANSPORT）   | 2            |
| `Data Length`| 数据部分的长度         | 4            |
| `Data`       | 数据部分（文件内容或消息）| 可变长度     |

### `TRANSPORT_FAILED` 事件

`TRANSPORT_FAILED` 事件用于传输失败时的处理。当数据包传输失败时，系统会通过该事件通知发送方数据包丢包。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（TRANSPORT_FAILED） | 2        |
| `Data Length`| 数据部分的长度         | 4            |
| `Data`       | 数据部分（失败的包信息）| 可变长度     |

---

## 3. 数据完整性

为了保证数据传输的完整性，`Q2P` 在接收到数据后，会对数据包的数量进行校验，如果数据包数量不够，则告诉发送端丢包信息中。

### 数据包数量校验及错误处理

```go
if len(transmissionRSYNS[key]) != 0 {
    log.Println("transport failed")

    syns := make([]uint32, 0, len(transmissionRSYNS[key]))
    for k, _ := range transmissionRSYNS[key] {
        syns = append(syns, k)
    }

    rAddr, err := net.ResolveUDPAddr("udp", addr)
    if err != nil {
        log.Println(err)
        return
    }

    peer.transportFailed(rAddr, hash, syns)
}
```

- **数据包计算**：随着数据包的接收，会删除transmissionRSYNS[key]列表的值，因此如果transmissionRSYNS[key]的长度不为0，则说明在传输过程中出现丢包现象。
- **丢包处理**：出现丢包情况时，接收端会向发送端发送`TRANSPORT_FAILED`事件，表示数据包在传输过程中出现了丢包。

---

## 4. 小结

`Q2P` 协议的数据包结构设计简单而高效，能够适应 P2P 网络通信中的各种需求。从数据包的构建到事件类型的处理，再到数据完整性的校验，整个传输过程都能够确保数据的可靠性和准确性。通过标准化的数据包格式，系统能够支持不同类型的事件和数据传输，确保在各种网络条件下都能顺利进行。

---

## 跳转

继续阅读了解更多关于错误处理与调试的细节：[**错误处理与调试**](07_error_handling_and_debugging.md)。
