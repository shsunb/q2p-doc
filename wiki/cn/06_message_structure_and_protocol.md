# 报文结构与协议

---

在 `Q2P` 系统中，数据传输是通过自定义的数据包结构来实现的。每个数据包包含了必要的头部信息和数据部分，确保在节点之间能够正确传递和解析数据。本文将详细介绍 `Q2P` 协议的数据包结构，分析每个字段的含义、长度范围及其作用。

## 1. 数据包结构

`Q2P` 的数据包由两部分组成：**头部**（固定部分）和 **数据部分**（可变长度）。数据包的头部包含了协议版本、事件类型、网络标识符（`NetworkID`）等信息，而数据部分则包含了传输的实际数据。

### 数据包头部结构

| 字段         | 描述                       | 长度（字节） | 说明                                      |
| ------------ | -------------------------- | ------------ | ----------------------------------------- |
| `NetworkID`  | 网络标识符（区分不同的 P2P 网络） | 2            | 每个网络中的节点拥有唯一的 `NetworkID`，用于标识网络 |
| `Event`      | 事件类型（如 `JOIN`、`CONNECT` 等）   | 2            | 标识当前数据包所对应的事件类型            |
| `Data Length`| 数据部分的长度               | 4            | 标明数据部分的实际大小                  |
| `Checksum`   | 校验和（可选）                | 2            | 校验数据的完整性（可选字段，取决于实现）  |

### 数据包体部分

| 字段        | 描述                      | 长度（字节） | 说明                                      |
| ----------- | ------------------------- | ------------ | ----------------------------------------- |
| `Data`      | 数据部分（如文件内容、消息等） | 可变长度     | 数据部分，根据 `Data Length` 进行分配   |

### 数据包示例

以一个 `TRANSPORT` 事件的请求为例：

| NetworkID (0x1234) | Event (TRANSPORT) | Data Length (0x0010) | Checksum (0x01F2) | Data (file chunk) |
| ------------------ | ----------------- | -------------------- | ------------------ | ------------------ |
| 0x1234             | 0x03              | 0x0010                | 0x01F2             | file chunk data    |


### 数据包构建过程

在 `Q2P` 中，每个数据包的构建过程都遵循上述结构。以下是一个数据包构建的示例：

```go
header := make([]byte, 0, 10)
binary.LittleEndian.PutUint16(header, peer.NetworkID)
binary.LittleEndian.PutUint16(header, TRANSPORT)
binary.LittleEndian.PutUint32(header, uint32(len(data)))
binary.LittleEndian.PutUint16(header, checksum)
```

1. **头部构建**：首先构建数据包的头部，包括 `NetworkID`、事件类型和数据长度。
2. **校验和计算**：通过 `calculateChecksum()` 函数计算数据的校验和，确保数据完整性。
3. **数据合并**：最后，将实际的数据部分添加到数据包中，形成完整的传输数据包。

---

## 2. 事件类型与数据包

在 `Q2P` 协议中，不同的事件类型会对应不同的操作和数据格式。以下是一些常见事件类型的说明及其对应的数据包结构。

### `JOIN` 事件

节点请求加入网络。当当前节点收到来访节点的JOIN事件时，它作为种子节点，要求每个已连接的节点向新节点打洞。因此，当前节点会向每个已连接的节点发送TOUCHREQUEST消息，并将新节点作为数据参数传输。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（JOIN）        | 2            |

### `TOUCHREQUEST` 事件

节点请求建立连接时，此网络事件应由种子节点发出，数据为要TOUCH的节点的UDP地址。当当前节点收到该地址后，将开始向目标UDP地址打洞（发送TOUCH消息），并向种子节点发送TOUCHED网络消息，以表示本节点已按照种子节点的建议向目标节点打洞。这里的“touch”指的就是打洞。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（CONNECT）     | 2            |
| `Data`       | 数据部分（节点请求建立连接）|  -            |

### `TOUCH` 事件

该事件不一定会收到，因为首次访问新节点时是向外打洞的动作，旨在帮助新节点连接到当前节点。然而，这个首次访问可能会被对方节点的外层路由拦截。如果对方节点直接暴露在公网，则可以收到该事件，此时无需打洞。无论是否收到该网络事件，都不会产生实质性的动作，这仅仅是一个过程标志。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（CONNECT）     | 2            |
| `Data`       | 数据部分               |  -            |

### `TOUCHED` 事件

当该节点收到TOUCHED网络事件时，说明作为种子节点的它被告知打洞节点已向目标节点打过洞。收到TOUCHED消息后，该种子节点将向打洞目标节点发送CONNECTREQUEST消息，请求其连接打洞节点。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（CONNECT）     | 2            |
| `Data`       | 数据部分（打洞完成消息）| -             |

### `CONNECTREQUEST` 事件

当该节点收到网络事件时，说明种子节点已知当前节点被打洞，打洞节点通过TOUCH操作已向其开启端口。因此，当前节点被告知可以连接打洞节点。收到该事件后，当前节点应向打洞节点发送CONNECT消息以建立连接。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（CONNECT）     | 2            |
| `Data`       | 数据部分（连接打洞节点信息）| -             |

### `CONNECT` 事件

当该节点作为打洞节点接收到目标节点的连接请求时，它会回复目标节点一个CONNECTED消息，并将该目标节点加入已连接列表。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（CONNECT）     | 2            |
| `Data`       | 数据部分（连接确认信息）| -             |

### `CONNECTED` 事件

收到CONNECTED消息后，该节点将对方节点加入已连接列表。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（CONNECT）     | 2            |
| `Data`       | 数据部分（连接确认信息）| -             |

### `TRANSPORT` 事件

`TRANSPORT` 事件用于数据传输。当节点需要发送数据时，数据会被分片并通过 `TRANSPORT` 消息传递。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（TRANSPORT）   | 2            |
| `Data`       | 数据部分（文件内容或消息）| 可变长度     |

Data内部结构：
| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `hash`  | HASH             | 0th ~ 16th bytes          |
| `length`      | Data总长度   | 16th ~ 20nd bytes            |
| `syn`       | placeholder for each SYN| 20nd ~ 24th bytes     |

### `TRANSPORT_FAILED` 事件

`TRANSPORT_FAILED` 事件用于传输失败时的处理。当数据包传输失败时，系统会通过该事件通知发送方数据包丢包。

#### 数据包示例：

| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| `NetworkID`  | 网络标识符             | 2            |
| `Event`      | 事件类型（TRANSPORT_FAILED） | 2        |
| `Data`       | 数据部分（失败的包信息）| 可变长度     |

Data内部结构：
| 字段         | 描述                   | 长度（字节） |
| ------------ | ---------------------- | ------------ |
| ``  |     1         | 0th ~ 16th bytes          |
| ``      |  2  | 16th ~ 20nd bytes            |
| ``       | 3| 20nd ~ 24th bytes     |

---

## 3. 数据完整性

为了保证数据传输的完整性，`Q2P` 在接收到数据后，会对数据包的数量进行校验，如果数据包数量不够，则告诉发送端丢包信息中。

### 数据包数量校验及错误处理

```go
if len(transmissionRSYNS[key]) != 0 {
    log.Println("transport failed")

    syns := make([]uint32, 0, len(transmissionRSYNS[key]))
    for k, _ := range transmissionRSYNS[key] {
        syns = append(syns, k)
    }

    rAddr, err := net.ResolveUDPAddr("udp", addr)
    if err != nil {
        log.Println(err)
        return
    }

    peer.transportFailed(rAddr, hash, syns)
}
```

- **数据包计算**：随着数据包的接收，会删除transmissionRSYNS[key]列表的值，因此如果transmissionRSYNS[key]的长度不为0，则说明在传输过程中出现丢包现象。
- **丢包处理**：出现丢包情况时，接收端会向发送端发送`TRANSPORT_FAILED`事件，表示数据包在传输过程中出现了丢包。

---

## 4. 小结

`Q2P` 协议的数据包结构设计简单而高效，能够适应 P2P 网络通信中的各种需求。从数据包的构建到事件类型的处理，再到数据完整性的校验，整个传输过程都能够确保数据的可靠性和准确性。通过标准化的数据包格式，系统能够支持不同类型的事件和数据传输，确保在各种网络条件下都能顺利进行。

---

## 跳转

继续阅读了解更多关于错误处理与调试的细节：[**错误处理与调试**](07_error_handling_and_debugging.md)。
